# Manufactor Architecture Summary

## 1. Project Overview

**Magic Card Manufactor** is a Python-based tool for creating custom Magic: The Gathering cards with:
- Automated card image generation from JSON definitions
- Cockatrice integration for digital gameplay
- Modular, GUI-ready architecture (currently CLI-only)
- Support for custom card types, tokens, and special frames

**Current Status**: On `refactor` branch, moving from legacy structure to modular architecture
**Key Recent Commit**: Better handling of supertypes in JSONs -- split into cardtype and per-supertype fields

---

## 2. Cards and Decks Structure

### 2.1 Card Definition (JSON Format)

Cards are stored as JSON objects within deck JSON files. Each card entry uses the card name as the key.

**Example Card (Complete):**
```json
{
  "Sheoldred, the Apocalypse": {
    "name": "Sheoldred, the Apocalypse",
    "mana": "{2}{b}{b}",
    "cardtype": "Creature",
    "subtype": "Phyrexian Praetor",
    "rarity": "Mythic",
    "power": "4",
    "toughness": "5",
    "rules": "Deathtouch\nWhenever you draw a card, you gain 2 life.\nWhenever an opponent draws a card, they lose 2 life.",
    "flavor": "\"Gix failed. I shall not.\"",
    "complete": 1,
    "tags": ["LifeDrain"],
    "legendary": 1
  }
}
```

**Card JSON Schema:**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| name | string | Yes | Card name |
| mana | string | No | Mana cost (e.g., "{2}{u}{r}" for 2 generic, blue, red) |
| cardtype | string | Yes | Card type (Creature, Instant, Sorcery, Land, Enchantment, Artifact, Planeswalker, Battle) |
| subtype | string | No | Card subtype (e.g., "Human Wizard", "Saga") |
| power | string/int | No | Power value (creatures only) |
| toughness | string/int | No | Toughness value (creatures only) |
| rarity | string | No | Card rarity (common, uncommon, rare, mythic) |
| rules | string | No | Main rules text |
| rules1-6 | string | No | Multi-line rules text (used for Sagas, multi-line cards) |
| flavor | string | No | Flavor text |
| special | string | No | Special card type (transform-front, transform-back, mdfc-front, mdfc-back) |
| related | string/list | No | Related card name(s) for double-faced cards |
| related_indicator | string | No | Text/mana cost for opposite side indicator |
| colors | list | No | Color identity list (["w", "u", "b", "r", "g"]) |
| tags | string/list | No | Tags for categorization (e.g., ["LifeDrain", "Removal"]) |
| **quantity** | int | No | **Number of copies in deck (default: 1)** |
| complete | int | No | 1 if card image is generated, 0 otherwise |
| real | int | No | 1 if real MTG card, 0 if custom |
| frame | string | No | Custom frame filename |
| artist | string | No | Artist name |
| artwork | string | No | Path to artwork file |
| legendary | int | No | 1 if legendary, 0/null if not |
| basic | int | No | 1 if basic land, 0/null if not |
| snow | int | No | 1 if snow permanent, 0/null if not |
| token | int | No | 1 if token, 0/null if not |

**Special Fields:**
- `_basics`: Special reserved key for basic land definitions
- `_common_tokens`: Special key for list of common token names (Treasure, Clue, Food, etc.)
- `_TOKEN_*`: Token definitions (generated by token parser)
- `_COMMON_TOKENS`: List of common token types

---

### 2.2 Deck Structure

Decks are organized in folders with the following structure:

```
Decks/
├── DeckName/
│   ├── DeckName.json              # Main deck definition
│   ├── DeckName_Tokens.json       # Generated token definitions
│   ├── Cards/                     # Generated card images
│   │   └── CardName.jpg
│   ├── Artwork/                   # Source artwork images
│   │   └── CardName.jpg
│   ├── Tokens/                    # Generated token images
│   │   └── TokenName.jpg
│   ├── Printing/                  # Print-ready card images
│   │   └── CardName.jpg
│   └── Reference/                 # Optional reference materials
```

**Deck JSON File (`DeckName.json`):**
- Contains deck metadata, all card definitions, and token definitions
- Uses structured format with three top-level sections
- Supports multiple artwork files per card (e.g., CardName_1.jpg, CardName_2.jpg)

---

### 2.3 New Deck JSON Format (Implemented)

**Complete Deck Example:**
```json
{
  "metadata": {
    "folder_name": "MyBurnDeck",
    "deck_name": "Red Deck Wins - Modern",
    "description": "Fast aggressive red deck with custom burn spells",
    "format": "Modern",
    "created": "2025-11-14T12:00:00Z",
    "last_modified": "2025-11-14T15:30:00Z",
    "author": "User",
    "tags": ["red", "aggro", "burn"],
    "setname": "MBD"
  },

  "cards": {
    "Lightning Bolt": {
      "name": "Lightning Bolt",
      "mana": "{r}",
      "cardtype": "Instant",
      "rules": "Lightning Bolt deals 3 damage to any target.",
      "flavor": "The sparkmage shrieked, calling on the sky...",
      "quantity": 4,
      "real": 1,
      "complete": 1,
      "rarity": "common",
      "colors": ["r"]
    },
    "Mountain": {
      "name": "Mountain",
      "cardtype": "Land",
      "subtype": "Mountain",
      "basic": 1,
      "quantity": 20,
      "real": 1,
      "complete": 0
    },
    "Dockside Extortionist": {
      "name": "Dockside Extortionist",
      "mana": "{1}{r}",
      "cardtype": "Creature",
      "subtype": "Goblin Pirate",
      "power": "1",
      "toughness": "2",
      "rules": "When Dockside Extortionist enters the battlefield, create X Treasure tokens, where X is the number of artifacts your opponents control.",
      "quantity": 1,
      "real": 1,
      "complete": 1,
      "rarity": "rare",
      "colors": ["r"],
      "artwork": "Artwork/DocksideExtortionist.jpg",
      "setname": "C19"
    }
  },

  "tokens": {
    "_TOKEN_Treasure": {
      "name": "Treasure",
      "cardtype": "Artifact",
      "subtype": "Treasure",
      "rules": "{T}, Sacrifice this artifact: Add one mana of any color.",
      "token": 1,
      "colors": [],
      "complete": 1,
      "quantity": 1,
      "source_cards": ["Dockside Extortionist"]
    }
  }
}
```

**Implementation Status:**
- ✅ **FULLY IMPLEMENTED** - `Deck.from_json()` auto-detects format
- ✅ **BACKWARD COMPATIBLE** - Old format decks still load correctly
- ✅ Tokens now included in main JSON (no separate `DeckName_Tokens.json`)
- ✅ Basic lands included in `cards` section (no special `_basics` field)
- ✅ Added `metadata` section for deck information
- ✅ Added `quantity` field for card copies
- ✅ Added `source_cards` field to track token origins
- ✅ Added `setname` field in metadata as deck-wide default (cards can override individually)
- ✅ `Deck.to_json()` exports in new format (or old format if requested)

**Set Code Handling:**
- Deck-level `setname` in metadata provides default for all cards (defaults to "UNK" if not specified)
- Individual cards can specify their own `setname` to override the deck default
- When exporting, card `setname` is only included if it differs from deck default
- Example: Deck has `setname: "MBD"`, but "Dockside Extortionist" specifies `setname: "C19"`

**Key Methods:**
- `Deck.from_json()` - Auto-detects format based on "metadata" key
- `Deck.to_json(use_new_format=True)` - Exports deck in new format
- `Deck.get_tokens(save_to_deck=True)` - Populates `self.tokens` with source tracking

---

### 2.4 Metadata Schema

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| folder_name | string | Yes | Name of deck folder (filesystem) |
| deck_name | string | Yes | Display name for deck |
| description | string | No | User-provided deck description |
| format | string | No | Format (Commander, Modern, Standard, etc.) |
| created | string (ISO 8601) | No | Deck creation timestamp |
| last_modified | string (ISO 8601) | No | Last modification timestamp |
| author | string | No | Deck creator name |
| tags | list | No | Categorization tags (e.g., ["aggro", "control"]) |
| commander | string | No | Commander card name (if format is Commander) |
| setname | string | No | Default set code for cards (default: "UNK"). Cards can override this individually |

---

### 2.5 Token Schema

Tokens are stored in the `"tokens"` section with `_TOKEN_` prefix keys.

**Additional Token Fields:**
| Field | Type | Required | Description |
|-------|------|----------|-------------|
| **source_cards** | list | No | **List of card names that create this token** |
| quantity | int | No | Number of token types (usually 1) |

All other fields follow the standard card schema (name, cardtype, subtype, power, toughness, rules, colors, token=1, complete).

---

### 2.6 Common Token Definitions

Common tokens (Treasure, Food, Clue, etc.) are defined in `config/common_tokens.json`. When the token parser detects a common token name in rules text, it automatically populates the token definition from this file.

**File location:** `/Users/fabiochiappina/Desktop/Artwork/Magic/Manufactor/config/common_tokens.json`

**Predefined common tokens:**
- Treasure
- Clue
- Food
- Blood
- Map
- Powerstone

Users can add custom common tokens through the settings interface.

---

## 3. Data Models

### 3.1 Core Classes

#### **Card** (`src/core/card.py` ~855 lines)
Represents a single Magic card with comprehensive properties and methods.

**Key Properties:**
- Basic info: `name`, `artist`, `artwork`, `setname`
- Mana: `mana` (parsed and sorted)
- Types: `cardtype`, `subtype`, `supertype` (legendary, token, basic, snow)
- Stats: `power`, `toughness`, `rarity`
- Text: `rules`, `rules1-6`, `flavor`
- Special: `special` (transform, mdfc), `related`, `related_indicator`
- Meta: `colors`, `tags`, `complete`, `real`, `frame`

**Key Methods:**
- Type checkers: `is_creature()`, `is_artifact()`, `is_land()`, etc.
- Color checkers: `is_white()`, `is_blue()`, `is_multicolored()`, `is_azorius()`, etc.
- Utilities:
  - `get_frame_filename()` - Determines correct frame based on colors/types
  - `get_mana_value()` - Returns converted mana cost
  - `get_colors()` - Extracts color identity
  - `get_tokens()` - Parses token definitions from rules text
  - `get_type_line()` - Builds complete type line
  - `sort_rules_text_mana_symbols()` - Normalizes mana symbols in rules

**Supertype Handling (New):**
- Previously: supertypes embedded in `cardtype` string
- Now: Separate fields `legendary`, `basic`, `snow`, `token`
- Backward compatible: Still parses from cardtype if individual fields not provided

---

#### **Deck** (`src/core/deck.py` ~480 lines)
Manages a collection of Card objects with statistics and analysis.

**Properties:**
- `cards`: List of Card objects
- `name`: Deck name
- `tags`: List of category tags
- `basics_dict`: Basic land definitions
- `common_tokens`: List of common token names

**Factory Methods:**
- `from_json(filepath, setname, deck_name)` - Load from JSON file
- `from_deck_folder(folder)` - Load from deck folder

**Statistics Methods:**
- `count_spells()`, `count_lands()` - Card counts
- `get_cardtypes()` - Distribution by card type
- `get_tokens()` - Extract all token definitions
- Print methods: `print_color_summary()`, `print_mana_summary()`, `print_type_summary()`, `print_tag_summary()`

**Token Handling:**
- Automatically extracts tokens from all card rules text
- Deduplicates and aggregates token properties
- Saves to `DeckName_Tokens.json`
- Marks tokens as incomplete if any source card is incomplete

---

#### **Mana** (`src/core/mana.py` ~473 lines)
Handles all mana-related operations for MTG cards.

**Supported Symbols:**
- Standard: w, u, b, r, g, c, s
- Variable: x, y, z
- Numeric: 0-20
- Dual hybrid: w/u, w/b, r/w, g/w, u/b, u/r, g/u, b/r, b/g, r/g
- Mono hybrid: 2/w, 2/u, 2/b, 2/r, 2/g
- Phyrexian: w/p, u/p, b/p, r/p, g/p
- Phyrexian hybrid: w/u/p, w/b/p, r/w/p, g/w/p, u/b/p, u/r/p, g/u/p, b/r/p, b/g/p, r/g/p
- Custom: e (exile mana)

**Key Methods:**
- `get_mana_symbols(mana_cost)` - Extract symbols and counts
- `get_mana_value(mana_cost)` - Calculate converted mana cost
- `get_colors(mana_cost)` - Extract color identity
- `get_colors_in_text(text)` - Parse colors from rules text
- `get_colors_produced_by_land(text)` - Parse land mana production
- `sort(mana_cost)` - Normalize to WUBRG order
- Color checkers: `is_monocolored()`, `is_multicolored()`, `is_azorius()`, etc.

---

#### **CardSet** (`src/core/card_set.py`)
Manages set codes and handles conflicts with official MTG sets.

**Key Methods:**
- `adjust_forbidden_custom_setname(setname)` - Prevent naming conflicts

---

#### **Ability** (`src/core/ability.py`)
Represents keyword abilities and ability elements.

---

### 3.2 Storage Layer

**JSON Loading** (`Deck.from_json`):
1. Loads JSON file with card definitions
2. Creates Card object for each entry (except special keys like `_basics`, `_common_tokens`)
3. Handles missing fields with defaults (None values)
4. Builds related_indicator for double-faced cards if missing
5. Processes tags and aggregates them by supertag

**No Traditional Database:**
- All data stored as JSON files
- Configuration in `config.json` (user paths)
- No SQL/relational database layer

---

## 4. Card Rendering Workflow

### 4.1 Rendering Pipeline

**High-Level Flow:**
```
Deck JSON → Card Object → CardDraw → PIL Image → Save to disk
```

### 4.2 Rendering Classes

#### **CardDraw** (`src/rendering/card_renderer.py` ~767 lines)
Handles image composition using PIL (Pillow).

**Initialization:**
```python
CardDraw(card: Card, save_path: str)
```
- Creates image from frame template
- Sets up drawing context

**Rendering Methods:**
- `write_name()` - Renders card name
- `write_type_line()` - Renders type/subtype
- `write_rules_text()` - Renders rules with text wrapping
- `paste_mana_symbols()` - Composites mana cost symbols
- `paste_set_symbol()` - Composites set symbol
- `paste_artwork(artwork_path)` - Composites artwork
- `paste_mdfc_indicator()` - Adds MDFC side indicator
- `write_power_toughness()` - Renders P/T for creatures
- `adjust_token_frame(black_token_cover)` - Applies token frame overlay
- `save()` - Saves final image to disk

#### **Helper Functions:**
- `create_card_image_from_Card(card, save_path, black_token_cover)` - High-level wrapper
- `create_printing_image_from_Card(card, saved_image_path, save_path)` - Creates print-ready version

### 4.3 Frame System

**Frame Files** (`Assets/CardBorders/`):
- Named by color scheme: `w_`, `u_`, `b_`, `r_`, `g_`, `c_`, `m_` (multicolor), `wu_`, `ub_`, etc.
- Special types: `creature`, `noncreature`, `artifact-creature`, `artifact-noncreature`, `land`, `enchantment-*`
- Special frames: `transform-front`, `transform-back`, `mdfc-front`, `mdfc-back`, `token-*`, `saga`
- Legendary variant: `_legendary` suffix

**Frame Selection Logic** (`Card.get_frame_filename()`):
1. Determine color scheme from mana cost
2. Determine base type (creature/noncreature/artifact/land/enchantment)
3. Handle special card types (saga, vehicle, planeswalker, battle)
4. Add legendary suffix if applicable
5. Return full path to frame file

**Example frames:**
- `b_creature_legendary.jpg` - Black legendary creature
- `wu_noncreature.jpg` - White/blue spell
- `g_token_creature.jpg` - Green token creature
- `m_mdfc-front_noncreature.jpg` - Multicolor MDFC front spell

---

### 4.4 Layout Constants (`src/rendering/layout_constants.py`)

Defines all pixel coordinates and sizing for:
- Card name position and font size
- Type line position and formatting
- Rules text area, wrapping, and line spacing
- Mana symbol positions and sizes
- Power/toughness position
- Set symbol position
- Colors and styling constants

---

## 5. Token Generation

### 5.1 Token Parser (`src/token_generation/token_parser.py`)

**Purpose:**
- Automatically detects tokens mentioned in card rules text
- Extracts token properties (name, type, P/T, abilities)

**Key Function:**
- `parse_tokens_from_rules_text(rules, card_name, complete, Card)` 
  - Returns tuple: (specialized_tokens, common_tokens)
  - specialized_tokens: List of dicts with full token properties
  - common_tokens: List of common token names (Treasure, Clue, Food, etc.)

**Integration:**
- Called by `Card.get_tokens()`
- Deck aggregates tokens across all cards
- Deduplicates tokens with same properties
- Generates `DeckName_Tokens.json`

---

## 6. Services Layer

Services act as bridge between UI and core logic (GUI-ready architecture).

### 6.1 DeckManager (`src/services/deck_manager.py`)

**Methods:**
- `load_deck_from_folder(deck_name)` - Load by folder name
- `load_deck_from_json(json_path, setname, deck_name)` - Load JSON directly
- `get_deck_statistics(deck)` - Comprehensive deck analysis
- `print_deck_summaries(deck)` - Console output of all summaries
- `list_available_decks()` - List all decks in DECK_PATH
- `create_deck_folder(deck_name)` - Create new deck with structure

---

### 6.2 ImageGenerator (`src/services/image_generator.py`)

**Methods:**
- `generate_deck_images(deck, save_path, skip_complete, automatic_tokens, progress_callback)`
  - Generate all card and token images
  - Optional progress callback for UI updates
  - Returns (cards_generated, tokens_generated)
- `generate_single_card_image(card, save_path, include_printing)` - Single card
- Private methods for directory management and image generation

---

### 6.3 SettingsManager (`src/services/settings_manager.py`)

**Methods:**
- `get_deck_path()`, `set_deck_path(path)` - Deck path management
- `get_cockatrice_path()`, `set_cockatrice_path(path)` - Cockatrice path
- `validate_paths()` - Check if paths exist and are writable
- `get_validation_errors()` - Get list of configuration issues
- `create_missing_directories()` - Attempt to create missing dirs
- `reset_to_defaults()` - Reset to default configuration
- `get_all_settings()` - Return complete settings dict

---

### 6.4 CockatriceExporter (`src/services/cockatrice_exporter.py`)

Exports decks to Cockatrice format.

---

## 7. File Organization

### 7.1 Source Code (`src/`)

```
src/
├── core/
│   ├── card.py              # Card data model (~855 lines)
│   ├── deck.py              # Deck management (~480 lines)
│   ├── mana.py              # Mana parsing (~473 lines)
│   ├── card_set.py          # Set management
│   ├── ability.py           # Ability definitions
│   └── __init__.py
├── rendering/
│   ├── card_renderer.py     # CardDraw class (~767 lines)
│   ├── layout_constants.py  # Position/sizing constants
│   └── __init__.py
├── token_generation/
│   ├── token_parser.py      # Token detection (~320 lines)
│   └── __init__.py
├── services/
│   ├── deck_manager.py      # Deck service
│   ├── image_generator.py   # Image generation service
│   ├── settings_manager.py  # Configuration service
│   ├── cockatrice_exporter.py
│   └── __init__.py
├── integration/
│   ├── cockatrice.py        # Cockatrice integration (~287 lines)
│   └── __init__.py
├── cli/
│   ├── build_deck.py        # Main CLI (~77 lines)
│   ├── prepare_reprints.py  # Reprint tool
│   ├── configure.py         # Configuration CLI
│   └── __init__.py
├── utils/
│   ├── paths.py             # Path configuration
│   ├── config.py            # Configuration loading
│   ├── file_utils.py        # File utilities
│   └── __init__.py
├── ui/
│   ├── windows/             # (Future GUI windows)
│   ├── dialogs/             # (Future dialogs)
│   ├── widgets/             # (Future custom widgets)
│   ├── resources/           # (Future UI resources)
│   └── __init__.py
└── __init__.py
```

### 7.2 Assets (`Assets/`)

```
Assets/
├── CardBorders/             # Frame templates (76+ .jpg files)
├── Symbols/                 # Mana and ability symbols
├── SetSymbols/              # Set symbols (expansion icons)
├── SagaSymbols/             # Saga chapter symbols
├── MDFC/                    # MDFC indicator symbols
└── Fonts/
    ├── Beleren-Bold.ttf       # Card name/type font
    ├── Beleren-Small-Caps.ttf # Token font
    └── MPlantin.ttf           # Rules text font
```

### 7.3 Configuration

**config.json** (User-specific, gitignored):
```json
{
    "paths": {
        "deck_path": "/path/to/Decks",
        "cockatrice_path": "/path/to/Cockatrice"
    }
}
```

**Default Paths:**
- Deck: `<project_parent>/Decks`
- Cockatrice (macOS): `~/Library/Application Support/Cockatrice/Cockatrice`
- Cockatrice (Windows): `%APPDATA%/Cockatrice/Cockatrice`
- Cockatrice (Linux): `~/.local/share/Cockatrice/Cockatrice`

---

## 8. Workflow: Creating and Rendering Cards

### 8.1 Complete Card Creation Workflow

1. **Define Cards in JSON:**
   - Create `Decks/MyDeck/MyDeck.json`
   - Define each card with name and properties

2. **Prepare Artwork:**
   - Place artwork images in `Decks/MyDeck/Artwork/`
   - Name matching card names (e.g., "Sheoldred, the Apocalypse.jpg")

3. **Load Deck:**
   ```python
   from src.core.deck import Deck
   deck = Deck.from_deck_folder("/path/to/Decks/MyDeck")
   ```

4. **Generate Card Images:**
   ```python
   from src.rendering.card_renderer import create_card_image_from_Card
   for card in deck.cards:
       create_card_image_from_Card(card, save_path)
   ```

5. **Generate Token Images:**
   ```python
   tokens_dict = deck.get_tokens()  # Saves DeckName_Tokens.json
   tokens_deck = Deck.from_json("DeckName_Tokens.json", "TKN", "Tokens")
   for token in tokens_deck.cards:
       create_card_image_from_Card(token, tokens_path)
   ```

6. **Export to Cockatrice:**
   ```python
   from src.integration.cockatrice import update_cockatrice
   update_cockatrice(deck)
   ```

### 8.2 CLI Usage

**Build a Deck:**
```bash
python3 -m src.cli.build_deck --deck "MyDeck"
```

**With automatic tokens:**
```bash
python3 -m src.cli.build_deck --deck "MyDeck" --automatic-tokens 1
```

**Configuration:**
```bash
python3 -m src.cli.configure --show              # Show current config
python3 -m src.cli.configure --set-deck-path /path
python3 -m src.cli.configure --validate         # Check paths
```

---

## 9. Architecture Diagram

```
┌─────────────────────────────────────────────────────────┐
│                    User Interface Layer                  │
│              (Future: tkinter, PyQt, or web)             │
└──────────────────────┬──────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────┐
│                   Services Layer                         │
│  ┌─────────────────────────────────────────────────┐   │
│  │ DeckManager | ImageGenerator | SettingsManager │   │
│  │ CockatriceExporter | (more services)            │   │
│  └─────────────────────────────────────────────────┘   │
└──────────────────────┬──────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────┐
│                    Core Layer                            │
│  ┌──────────────────────────────────────────────┐       │
│  │ Card | Deck | Mana | CardSet | Ability       │       │
│  └──────────────────────────────────────────────┘       │
└──────────────────────┬──────────────────────────────────┘
                       │
            ┌──────────┼──────────────┐
            │          │              │
    ┌───────▼──┐  ┌────▼──────┐  ┌───▼──────────┐
    │Rendering │  │Token Gen  │  │Integration   │
    │  Layer   │  │  Layer    │  │(Cockatrice)  │
    └──────────┘  └───────────┘  └──────────────┘
            │          │              │
            └──────────┼──────────────┘
                       │
    ┌──────────────────▼──────────────────┐
    │      Utilities & File I/O           │
    │  ┌──────────────────────────────┐   │
    │  │ paths | config | file_utils  │   │
    │  └──────────────────────────────┘   │
    └─────────────────────────────────────┘
```

---

## 10. Key Technical Decisions

### 10.1 No Database
- **Rationale**: Simple file-based storage sufficient for single-user tool
- **Format**: JSON for human readability and Python compatibility
- **Advantage**: No external dependencies, easy to version control decks

### 10.2 Three-Layer Architecture
- **UI → Services → Core**: Clean separation for GUI development
- **Services Layer**: Provides high-level API for UI without exposing core complexity
- **Testability**: Each layer can be tested independently

### 10.3 Supertype Refactoring
- **Old**: Supertypes (legendary, token) embedded in `cardtype` string
- **New**: Separate fields (`legendary`, `basic`, `snow`, `token`)
- **Compatibility**: Still parse from cardtype if individual fields missing
- **Reason**: Cleaner data model, easier frame selection

### 10.4 Token Parsing
- **Automatic**: Parses rules text to identify tokens
- **Deduplication**: Combines identical tokens across cards
- **Storage**: Separate `_Tokens.json` file with `_TOKEN_*` prefixes
- **Inheritance**: Marks token incomplete if source card incomplete

### 10.5 Frame Template System
- **Consistency**: 76+ pre-designed frames for all card types/colors
- **Automatic Selection**: Card.get_frame_filename() picks correct frame
- **Flexibility**: Custom frames can be specified in JSON

---

## 11. Example: Complete Card Data Flow

**Input (JSON):**
```json
{
  "Lightning Bolt": {
    "name": "Lightning Bolt",
    "mana": "{r}",
    "cardtype": "Instant",
    "rarity": "Uncommon",
    "rules": "Lightning Bolt deals 3 damage to any target.",
    "flavor": "The sparkmage shrieked...",
    "complete": 1,
    "tags": ["Removal"]
  }
}
```

**Processing:**
1. JSON loaded → Card object created
2. `mana = "{r}"` → Mana.get_colors() → colors = ['r']
3. `cardtype = "Instant"` → is_spell() = True
4. `colors = ['r']` + `cardtype = "Instant"` → get_frame_filename() → `r_noncreature.jpg`
5. CardDraw loads frame template, composites artwork, renders text
6. PIL saves final image to `Cards/Lightning Bolt.jpg`

**Output:**
- Rendered card image ready for printing or Cockatrice
- Optional printing version with crop marks

---

## 12. Planned Web UI Architecture

### 12.1 Overview

The web UI will provide a modern deck-building interface similar to Moxfield, while preserving the current single-JSON-per-deck storage format. This hybrid approach maintains version control benefits and atomic deck operations while enabling fast single-card operations through an API layer.

### 12.2 Architecture Layers

```
┌─────────────────────────────────────────┐
│  Frontend (React/Vue/Svelte)            │
│  - Deck browser & card gallery          │
│  - Card editor (JSON + live preview)    │
│  - Drag-and-drop deck building          │
│  - Real-time card rendering              │
└─────────────────┬───────────────────────┘
                  │ REST/GraphQL API
┌─────────────────▼───────────────────────┐
│  Backend API (Flask/FastAPI)            │
│  - Deck/card CRUD endpoints             │
│  - In-memory deck caching               │
│  - Image generation queue               │
│  - WebSocket for render progress        │
└─────────────────┬───────────────────────┘
                  │ Python imports
┌─────────────────▼───────────────────────┐
│  Core Layer (Existing Code)             │
│  - Card, Deck, Mana classes             │
│  - CardRenderer, TokenGenerator         │
│  - Services layer                        │
└─────────────────┬───────────────────────┘
                  │ File I/O
┌─────────────────▼───────────────────────┐
│  Storage (Current Format)               │
│  - DeckName.json (all cards)            │
│  - Generated images & tokens            │
│  - Git-trackable single files           │
└─────────────────────────────────────────┘
```

### 12.3 API Endpoints

**Deck Operations:**
```
GET    /api/decks                      # List all decks
GET    /api/decks/:deckName            # Get full deck JSON + metadata
POST   /api/decks                      # Create new deck
DELETE /api/decks/:deckName            # Delete deck
PATCH  /api/decks/:deckName            # Update deck metadata
```

**Card Operations:**
```
GET    /api/decks/:deckName/cards                    # List all cards in deck
GET    /api/decks/:deckName/cards/:cardName          # Get single card JSON
POST   /api/decks/:deckName/cards                    # Add new card to deck
PATCH  /api/decks/:deckName/cards/:cardName          # Update single card
DELETE /api/decks/:deckName/cards/:cardName          # Remove card from deck
POST   /api/decks/:deckName/cards/:cardName/render   # Render single card image
```

**Batch Operations:**
```
POST   /api/decks/:deckName/render-all              # Render all cards in deck
GET    /api/decks/:deckName/tokens                  # Get generated tokens
POST   /api/decks/:deckName/regenerate-tokens      # Re-parse and generate tokens
```

**Image & Asset Operations:**
```
GET    /api/decks/:deckName/cards/:cardName/image   # Get rendered card image
POST   /api/decks/:deckName/cards/:cardName/artwork # Upload artwork
GET    /api/frames                                  # List available frame templates
GET    /api/frames/:frameName/preview               # Get frame preview image
```

**Statistics & Analysis:**
```
GET    /api/decks/:deckName/stats                   # Deck statistics (mana curve, colors, etc.)
GET    /api/decks/:deckName/mana-curve              # Mana curve data for charts
GET    /api/decks/:deckName/color-distribution      # Color pie data
```

### 12.4 Example API Flow: Edit Single Card

**User clicks "Edit" on Lightning Bolt:**

```http
GET /api/decks/Test/cards/Lightning%20Bolt
```

**Response:**
```json
{
  "name": "Lightning Bolt",
  "mana": "{r}",
  "cardtype": "Instant",
  "rules": "Lightning Bolt deals 3 damage to any target.",
  "flavor": "The sparkmage shrieked, calling on the sky...",
  "rarity": "common",
  "colors": ["r"],
  "complete": 1,
  "artwork": "Artwork/LightningBolt.jpg"
}
```

**User modifies rules text and clicks "Save & Render":**

```http
PATCH /api/decks/Test/cards/Lightning%20Bolt
Content-Type: application/json

{
  "rules": "Lightning Bolt deals 4 damage to any target."
}
```

**Backend Process:**
1. Load `Test.json` from disk (or from cache)
2. Update only the `Lightning Bolt` card object
3. Write entire deck JSON back to disk
4. Trigger card image re-render
5. Return updated card + new image URL

**Response:**
```json
{
  "success": true,
  "card": { /* updated card JSON */ },
  "image_url": "/api/decks/Test/cards/Lightning%20Bolt/image?v=1234567890",
  "render_status": "queued"
}
```

**WebSocket event (when render completes):**
```json
{
  "event": "card_rendered",
  "deck": "Test",
  "card": "Lightning Bolt",
  "image_url": "/api/decks/Test/cards/Lightning%20Bolt/image?v=1234567891",
  "status": "complete"
}
```

### 12.5 Backend Caching Strategy

To avoid repeatedly reading/writing JSON files:

```python
class DeckCache:
    """In-memory cache for deck JSON files"""

    def __init__(self):
        self._cache = {}  # {deck_name: {'data': Deck, 'modified': timestamp}}
        self._lock = threading.Lock()

    def get_deck(self, deck_name: str) -> Deck:
        """Load deck from cache or disk"""
        with self._lock:
            if deck_name in self._cache:
                return self._cache[deck_name]['data']

            # Load from disk using existing DeckManager
            deck = DeckManager.load_deck(deck_name)
            self._cache[deck_name] = {
                'data': deck,
                'modified': time.time()
            }
            return deck

    def update_card(self, deck_name: str, card_name: str, updates: dict):
        """Update single card and persist to disk"""
        deck = self.get_deck(deck_name)

        # Update card in memory
        card = deck.cards[card_name]
        for key, value in updates.items():
            setattr(card, key, value)

        # Write entire deck JSON to disk
        deck.save_to_json()  # Uses existing Deck.to_json() method

        # Update cache timestamp
        self._cache[deck_name]['modified'] = time.time()

        return card
```

### 12.6 Frontend Components

**Key UI Components:**

1. **DeckBrowser**
   - Grid/list view of all decks
   - Thumbnail previews (commander or first card)
   - Deck statistics summary

2. **DeckView**
   - Card gallery with filtering (by color, type, mana cost)
   - Mana curve visualization
   - Color distribution pie chart
   - Deck statistics panel

3. **CardEditor**
   - Split view: JSON editor (left) + live preview (right)
   - Syntax highlighting for JSON
   - Validation (required fields, mana syntax)
   - "Render" button triggers image generation
   - Real-time preview updates as JSON changes

4. **CardGallery**
   - Masonry/grid layout of card images
   - Click to enlarge/edit
   - Drag-and-drop to reorder
   - Multi-select for batch operations

5. **TokenViewer**
   - Auto-generated tokens display
   - Shows source card for each token
   - Re-generate tokens when rules text changes

### 12.7 Why Keep Single JSON Per Deck?

**Advantages:**

1. **Atomic Deck Operations**
   - Decks are versioned as single units in git
   - Easy to share/export entire decks
   - Token generation scans all cards at once
   - Statistics calculated holistically

2. **Simpler Backend Logic**
   - One file read/write per deck operation
   - No complex database migrations
   - Human-readable, easy to debug
   - Existing codebase already handles this format

3. **Version Control Friendly**
   - Git diff shows exactly what changed in a deck
   - Merge conflicts are manageable
   - History tracks deck evolution over time

4. **Performance**
   - Reading one JSON file is fast (typical deck: 60 cards = ~20-50KB)
   - Caching entire deck in memory is cheap
   - Writing back to disk is infrequent (only on save)

**Trade-offs:**

- Need backend caching to avoid repeated file I/O
- Concurrent edits require conflict resolution (last-write-wins or optimistic locking)
- Large decks (100+ cards) may need pagination in UI

### 12.8 Alternative: Card Library System

If users frequently **reuse custom cards across decks**, consider:

```
/Cards/
  ├── user_created/
  │   ├── lightning_bolt.json        # Individual card definitions
  │   ├── counterspell.json
  │   └── ...
  └── library/
      └── community_cards.json

/Decks/
  ├── Burn/
  │   └── deck.json                  # References cards by ID
  └── Control/
      └── deck.json
```

**Deck JSON would contain references:**
```json
{
  "deck_name": "Burn",
  "cards": [
    {"card_id": "lightning_bolt", "quantity": 4},
    {"card_id": "lava_spike", "quantity": 4}
  ]
}
```

**When to use this:**
- Users maintain a "card pool" library
- Same custom cards appear in many decks
- Want searchable card database
- Support card versioning/revisions

**When NOT to use:**
- Each deck has unique, one-off custom cards (current use case)
- Decks are self-contained and independent
- Simpler data model is preferred

### 12.9 Implementation Phases

**Phase 1: Backend API (Flask/FastAPI)**
- Set up REST endpoints for deck/card CRUD
- Implement DeckCache for in-memory storage
- Wire up existing Card/Deck/Mana classes
- Add CORS for frontend communication

**Phase 2: Image Generation Service**
- Async rendering queue (Celery/RQ)
- WebSocket for progress updates
- Batch rendering optimization
- Image caching strategy

**Phase 3: Frontend Foundation**
- Deck browser + list view
- Card gallery component
- Basic routing (React Router/Vue Router)

**Phase 4: Card Editor**
- JSON editor with syntax highlighting
- Live preview pane
- Form validation
- Render trigger + progress indicator

**Phase 5: Advanced Features**
- Drag-and-drop deck building
- Mana curve charts (Chart.js/D3)
- Token viewer
- Artwork upload

**Phase 6: Polish**
- Dark mode
- Keyboard shortcuts
- Export to Cockatrice from UI
- Print view

---

## 13. Current Limitations and TODOs

### Not Implemented:
- Planeswalkers (Card.get_frame_filename() raises ValueError)
- Battle cards (same limitation)
- Adventures/Omens (subspells)
- GUI (planned Phase 7)

### Known Issues:
- Land double-faced cards: Related indicator generation not accurate (reads rules text)
- Duplicate token names: Need to append _B, _C suffixes (currently only _#)

### In Progress:
- Phase 5: Complete services layer
- Phase 6: Comprehensive unit tests
- Phase 7: GUI development

---

## 13. External Dependencies

**Required:**
- **Pillow** (>=10.0.0) - Image processing (PIL)
- **num2words** (>=0.5.12) - Number-to-word conversion
- **Python 3.7+**

**Optional:**
- Cockatrice (for deck export, not required for card generation)

---

## 14. File Paths (Important Constants)

From `src/utils/paths.py`:
```python
PROJECT_ROOT = /Users/fabiochiappina/Desktop/Artwork/Magic/Manufactor

ASSETS_PATH = PROJECT_ROOT/Assets
CARD_BORDERS_PATH = ASSETS_PATH/CardBorders
SYMBOL_PATH = ASSETS_PATH/Symbols
SET_SYMBOL_PATH = ASSETS_PATH/SetSymbols
SAGA_SYMBOL_PATH = ASSETS_PATH/SagaSymbols
MDFC_INDICATOR_PATH = ASSETS_PATH/MDFC
FONT_PATHS = {name, token, type, rules, flavor} in ASSETS_PATH/Fonts

DECK_PATH = (from config.json)
COCKATRICE_PATH = (from config.json)
```

---

## Summary

Manufactor is a well-structured, modular MTG card creation tool with:

1. **Clean Architecture**: Three-layer design (UI/Services/Core) ready for GUI development
2. **JSON-based Storage**: Simple, versioned card definitions
3. **Comprehensive Card Model**: Handles MTG complexity (mana, supertypes, tokens, special frames)
4. **Automated Rendering**: PIL-based image composition with 76+ frame templates
5. **Token Generation**: Automatic token detection and image generation
6. **Cockatrice Integration**: Export to popular MTG digital platform
7. **CLI Tools**: Command-line interface for all operations
8. **Configuration System**: User-specific path settings with validation

The system is currently functional and CLI-ready, with architecture prepared for future GUI development.
